# 6. 코틀린 타입 시스템

## 6.1 널 가능성

### 6.1.1 널이 될 수 있는 타입

코틀린과 자바의 가장 중요한 차이는 코틀린 타입 시스템이 널이 될 수 있는 타입을 명시적으로 지원한다는 점

- 널과 다른 타입을 인자로 받을 수 있게 하려면 타입 이름 뒤에 물음표를 명시 `fun strLenSafe(s: String?) = ...`

- 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한
- 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다.
- 널이 될 수 있는 타입의 값을 널이 될 수 없는 타입의 파라미터를 받는 함수에 전달할 수 없다.

가장 중요한 일은 바로 null과 비교하는 것

null과 비교하고 나면 컴파일러는 그 사실을 기억하고 null이 아님이 확실한 영역에서는 해당 값을 널이 될 수 없는 타입의 값처럼 사용할 수 있다.

### 6.1.2 타입의 의미

> 자바에서도 annoctation을 통해 값이 널이 될 수 있는지 여부를 표시(`@Nullable`, `@NotNull`)하기도 한다. 하지만 이런 도구는 표준 자바 컴파일 절차의 일부가 아니기 때문에 일관성 있게 적용된다는 보장을 할 수 없다. 그리고 오류의 정확한 위치를 찾기 위해 라이브러리를 포함하는 모든 코드베이스에서 애노테이션을 추가하는 일도 쉽지 않다.

### 6.1.3 안전한 호출 연산자: ?.

```kotlin
s?.toUpperCase()
```

`?.`는 null 검사와 메서드 호출을 한 번의 연산으로 수행한다.

- 결과도 `null`이 될 수 있다.
- 메서드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다.

### 6.1.4 엘비스 연산자: ?:

null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있는 연산자를 제공 = 엘비스 연산자

```kotlin
fun foo(s:String?) {
  val t: String = s ?: ""
}
```

코틀린에서는 return이나 throw 등의 연산도 식이기 때문에 엘비스 연산자의 우항에 넣을 수 있다.

```kotlin
val address = person.company?.address ?: throw IllegalArgumentException("No address")
with (address) {
  // address는 null이 아니다.
}
```

### 6.1.5 안전한 캐스트: as?

as를 사용할 때마다 is를 통해 미리 as로 변환 가능한 타입인지 검사해볼 수도 있지만, 코틀린은 as?를 통해 값을 대상 타입으로 변환할 수 없으면 null을 반환하도록 할 수 있다.

일반적으로 `as?`를 사용할 때 캐스트를 수행한 뒤에 엘비스 연산자를 사용한다.

```kotlin
fun equals(o: Any?): Boolean {
  val otherPerson = o as? Person ?: return false
  return oterPerson.firstName && oterPerson.lastName == lastName
}
```

### 6.1.6 널 아님 단언: !!

값이 null이 아님을 단언할 때 사용한다.

어떤 값이 null이었는지 확실히 하기 위해 여러 `!!`를 한 줄에 함께 쓰는 일을 피하라

### 6.1.7 let 함수

let 함수를 안전한 호출 연산자와 함께 사용하면 원하는 식을 평가해서 결과가 널인지 검사한 다음에 그 결과를 변수에 넣는 작업을 간단한 식을 사용해 한꺼번에 처리할 수 있다.

let 함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다(?)

```kotlin
fun sendEmailTo(email: String) { }

if (Email != null) sendEmailTo(email)
// 이렇게 할 수도 있지만,

email?.let { sendEmailTo(it) }
```

`let`을 쓰면 긴 식의 결과를 저장하는 변수를 따로 만들 필요가 없다.

여러 값이 널인지 검사해야 한다면 let을 중첩시켜 처리하는 것보다 if를 사용하는 것이 낫다.

### 6.1.8 나중에 초기화할 프로퍼티

`lateinit` 변경자를 붙이면 프로퍼티를 나중에 초기화할 수 있다.

- 나중에 초기화하는 프로퍼티는 항상 `var`여야 한다.

```kt
class MyService {
    fun performAction(): String = "foo"
}

class MyTest {
    private lateinit var myService: MyService

    @Before fun setUp() {
        myService = MyService()
    }

    @Test fun testAction() {
        Assert.assertEquals("foo",
            myService.performAction())
    }
}
```

- `@Before`, `@Test` 는 JUnit4 annotation이다.

### 6.1.9 널이 될 수 있는 타입 확장

널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null 값을 다루는 강력한 도구로 활용할 수 있다.

- ex. `String?`타입의 `isNullOrBlank` 메서드

`let` 함수도 널이 될 수 있는 타입의 값에 대해 호출할 수 있지만, let은 this가 널인지 검사하지 않는다.

### 6.1.10 타입 파라미터의 널 가능성

타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다.
타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야 한다.

```kt
fun <T: Any> printHashCode(t: T) {
  println(t.hashCode())
}
```

### 6.1.11 널 가능성과 자바

자바 타입 시스템은 널 가능성을 지원하지 않는다.

- 자바 코드에 애노테이션으로 표시된 널 가능성 정보를 코틀린도 활용한다.
- 널 가능성 애노테이션이 없는 경우 자바의 타입은 코틀린의 플랫폼 타입이 된다.

**플랫폼 타입** : 코틀린이 널 관련 정보를 알 수 없는 타입

- 자바와 마찬가지로 수행하는 모든 연산에 대한 책임은 개발자한테 있다.

**상속**
코틀린에서 자바 메서드를 오버라이드할 때 그 메서드의 파라미터와 반환 타입을 널이 될 수 있는 타입으로 선언할지 될 수 없는 타입으로 선언할지 결정해야 한다.

## 6.2 코틀린의 원시 타입

### 6.2.1 원시 타입: Int, Boolean 등

자바는 참조 타입이 필요한 경우 특별한 래퍼 타입으로 원시 타입 값을 감싸서 사용한다.
하지만 코틀린은 원시 타입과 래퍼 타입을 구분하지 않으므로 항상 같은 타입을 사용한다.

### 6.2.2 널이 될 수 있는 원시 타입: Int?, Boolean? 등

코틀린에서 널이 될 수 있는 원시 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일된다.

### 6.2.3 숫자 변환

코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다.
결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능

```kt
val i = 1
val l: Long = i
```

는 컴파일 오류가 발생한다.

대신 직접 변환 메서드를 호출해야 한다.

```kt
val i = 1
val l: Long = i.toLong()
```

코드에서 동시에 여러 숫자 타입을 사용하려면 예상치 못한 동작을 피하기 위해 각 변수를 명시적으로 변환해야 한다.

### 6.2.4 Any, Any?: 최상위 타입

자바에서 `Object`가 클래스 계층의 최상위 타입이듯 코틀린에서는 `Any` 타입이 모든 널이 될 수 없는 타입의 조상 타입이다.
코틀린에서는 원시 타입을 포함한 모든 타입의 조상타입이 `Any`다.

- 내부적으로 `Any`타입은 자바의 `java.lang.Object`에 대응한다.

### 6.2.5 Unit 타입: 코틀린의 void

전혀 반환하지 않는 함수의 반환 타입으로 `Unit`을 쓸 수 있다.

- Unit은 모든 기능을 갖는 일반적인 타입
- void와 달리 Unit을 타입 인자로 쓸 수 있다.
- Unit 타입의 함수는 Unit 값을 묵시적으로 반환
- 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit을 쓸 때 유용

```kt
interface Processor<T> {
  fun process(): T
}

class NoResultProcessor: Processor<Unit> {
  override fun process() {
    // return 명시 필요 x
  }
}
```

다른 방법으로 `java.lang.Void`를 사용하는 방법도 있다.

### 6.2.6 Nothing 타입: 이 함수는 결코 정상적으로 끝나지 않는다

코틀린에는 결코 성공적으로 값을 돌려주는 일이 없으므로 반환 값이라는 개념 자체가 의미 없는 함수가 일부 존재
이러 ㄴ경우를 표현하기 위해 코틀린에는 `Nothing`이라는 특별한 반환 타입이 있다.

```kt
fun fail(message: String): Nothing {
  throw IllegalStateException(message)
}
```

`Nothing` 타입은 아무 값도 포함하지 않는다. 따라서 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다.

## 6.3 컬렉션과 배열

### 6.3.1 널 가능성과 컬렉션

### 6.3.2 읽기 전용과 변경 가능한 컬렉션

코틀린에서는 컬렉션 안의 데이터에 접근하는 인터페이스와 컬렉션 안의 데이텅를 변경하는 인터페이스를 분리했다.

`kotlin.collections.Collection` 인터페이스는 컬렉션 안의 원소를 이터레이션하고, 컬렉션의 크기를 얻고, 검사 및 읽기 등 여러 연산을 수행할 수 있지만, 원소를 추가하거나 제거하는 메소드는 없다.
이를 하려면 `kotlin.collections.MutableCollection` 인터페이스를 사용해야 한다.

읽기 전용 컬렉션이라고 해서 꼭 변경 불가능한 컬렉션일 필요는 없다.
인터페이스는 실제로 같은 인스턴스를 가리키는 변경 가능한 인터페이스 타입의 참조도 있을 수 있다.
따라서 읽기 전용 컬렉션이 항상 `스레드 안전`을 보장하지 않는다.

### 6.3.3 코틀린 컬렉션과 자바

모든 코틀린 컬렉션은 그에 상은하는 자바 컬렉션 인터페이스의 인스턴스이므로, 코틀린과 자바 사이를 오갈 때 아무 변환도 필요 없다. 하지만 코틀린은 모든 자바 컬렉션 인터페이스마다 읽기 전용 인터페이스와 변경 가능한 인터페이스라는 두 가지 표현을 제공한다.

자바는 읽기 전용 컬렉션과 변경 가능 컬렉션을 구분하지 않으므로, 코틀린에서 읽기 전용으로 선언된 객체라도 자바 코드에서는 그 컬렉션 객체의 내용을 변경할 수 있다.

### 6.3.4 컬렉션을 플랫폼 타입으로 다루기

자바쪽에서 선언한 컬렉션 타입의 변수를 코틀린에서는 플랫폼 타입으로 본다.

플랫폼 타입에서 널 가능성을 다룰 때처럼 이런 경우에도 오버라이드하려는 메서드의 자바 컬렉션 타입을 어떤 코틀린 컬렉션 타입으로 표현할지 결정해야 한다.

- 컬렉현이 널이 될 수 있는가?
- 컬렉션의 원소가 널이 될 수 있는가?
- 오버라이드하는 메서드가 컬렉션을 변경할 수 있는가?

```java
interface FileContentProcessor {
  void processContents(File path,
    byte[] binaryContents,
    List<String> textContents);
}
```

- 일부 파일은 이진 파일이며 이진 파일 안의 내용은 텍스트로 표현 불가능할 수 있으므로 리스트는 널이 될 수 있다.
- 파일의 각 줄은 널일 수 없으므로 이 리스트의 원소는 널이 될 수 없다.
- 이 리스트는 파일의 내용을 표현하며 그 내용을 바꿀 필요가 없으므로 읽기 전용이다.

이런 옵션을 선택하면 다음과 같이 구현할 수 있다.

```kt
class FileIndexer: FileContentProcessor {
  override fun processContents(path: File,
    binaryCOntetns: ByteArray?,
    textContents: List<String>?) { ... }
}
```

### 6.3.5 객체의 배열과 원시 타입의 배열

코틀린에서 배열을 만드는 방법

- `arrayOf`
- `arrayOfNulls`
- `Array` 생성자
