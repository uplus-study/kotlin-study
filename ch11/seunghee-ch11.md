## 11장 DSL 만들기

영역 특화 언어(DSL, Domain-Specific Language): 특정 주제에 특화된 언어를 의미하며, 데이터 베이스에 접근하기 위한 SQL이 대표적
코틀린에서는 고차함수와 람다식의 특징을 이용하여 읽기 좋고 간략한 코드를 만들 수 있음


### API에서 DSL로
라이브러리 개발자 뿐만 아니라 모든 개발자는 깔끔한 API 작성해야 할 책임이 있음.
> 깔끔한 API란?
> * 코드를 읽는 사람들이 어떤 일이 벌어질지 명확하게 이해할 수 있어야 한다.
> * e.g.) 이름 잘붙이기, 적절한 개념 사용 등..
> * 불필요한 구문이나 번잡한 준비 코드가 적고 코드가 간결해야 한다.

##### 코틀린에서 깔끔한 API를 작성하도록 도와주는 기능
| 일반 구문                              | 간결한 구문                                    | 사용한 언어 특성      |
|------------------------------------|-------------------------------------------|----------------|
| `StringUtil.capitalize(s)`         | `s.capitalize()`                          | 확장 함수          |
| `1.to("one")`                      | `1 to "one"`                              | 중위 호출          |
| `set.add(2)`                       | `set += 2`                                | 연산자 오버로딩       |
| `map.get("key")`                   | `map["key"]`                              | get 메서드에 대한 관례 |
| `file.use({ f -> f.read() } )`     | `file.use { it.read() }`                  | 람다를 괄호 밖으로 빼내는 관례 |
| `sb.append("yes") sb.append("no")` | `with (sb) { append("yes") append("no")}` | 수신 객체 지정 람다    |


#### 영역 특화 언어라는 개념

프로그래밍 언어는 컴퓨터로 풀 수 있는 모든 문제를 충분히 풀 수 있는 기능을 제공하는 범용 프로그래밍 언어 와 특정 과업 또는 영역에 초점을 맞추고 그 영역에 필요하지 않은 기능을 없앤 영역 특화 언어 로 구분할 수 있음

* 범용 프로그래밍 언어
    * 명령적인 특징을 가지고 있다.
        * ex) 어떤 연산을 완수하기 위해 필요한 각 단계를 순서대로 정확히 기술

* 영역 특화 언어
    * SQL과 정규식과 같이 제공하는 기능을 스스로 제한함으로써 오히려 더 효율적으로 목표를 달성할 수 있 도록 하는 특징을 가진 언어
    * 선언적인 특징을 가지고 있다.
        * 원하는 결과를 기술하기만 하고 그 결과를 위한 세부 실행은 언어를 해석하는 엔진에 맡김
    * 특정 영역에 특화되어 자체 문법이 있기 때문에 범용 언어로 만든 애플리케이션과 조합하기가 어렵다.
        * ex) 내부 DB 사용 시 쿼리문 작성 <-- 컴파일 시점에 검증 불가 등..

#### 내부 DSL
내부 DSL은 범용 언어로 작성된 프로그램의 일부며, 범용 언어와 동일한 문법을 사용한다. 그렇기 때문에 내부 DSL은 다른 언어가 아니라 DSL의 핵심 장점을 유지하면서 주 언어를 특별한 방법으로 사용하는 것이다.

#### DSL의 구조

DSL과 일반 API를 구분하는 방법

* DSL은 구조 또는 문법을 독립적으로 가진다.
* 위의 예제에서 여러 함수 호출을 조합해서 연산을 만드는 것 또한 내부 DSL 적인 특징이다.

DSL 구조의 장점

* 같은 문맥을 함수 호출 시마다 반복하지 않고도 재사용할 수 있다.
* 일반 명령-질의 API 사용 시 중복 코드가 늘어나는 것을 볼 수 있다.


#### 내부 DSL로 HTML 만들기

```kotlin
fun createSimpleTable() = createHtml().
	table {
    tr {
      td { +"cell" }
    }
  }
```

* `createSimpleTable()`은 HTML 조각이 들어있는 문자열을 반환함
  [장점]
* 타입 안정성을 보장한다.
    * 위 코드에서 td는 tr 내에서만 사용할 수 있고 위반시 컴파일 에러
* 코틀린 코드를 원하는대로 사용할 수 있고, 맵에 들어있는 원소에 따라 동적으로 표의 칸을 생성할 수 있음


### 구조화된 API 구축: DSL에서 수신 객체 지정 DSL 사용

#### 수신 객체 지정 람다와 확장 함수 타입

* 수신 객체 지정 람다를 인자로 넘기므로 람다 내에서 `it`를 사용하지 않아도 된다.
* 확장 함수 타입 선언은 `<수신 객체 타입>.(param1, param2) -> <반환타입>` 형태로 명시한다.

* `apply` 함수는 인자로 받은 람다나 함수를 호출하면서 자신의 수신 객체를 람다나 함수의 묵시적 수신 객체로 사용한다.
* `apply`함수
    * 수신 객체 타입에 대한 확장 함수로 선언됐기 때문에 수신 객체의 메소드처럼 불리며, 수신 객체를 묵시적 인자(this)로 받게 됨.
    * 수신 객체를 다시 반환한다.
* `with` 함수
    * 수신 객체를 첫번째 파라미터로 받는다.
    * 람다를 호출해 얻은 결과를 반환한다.


#### 수신 객체 지정 람다 & HTML 빌더

##### HTML 빌더란? (https://github.com/Kotlin/kotlinx.html 참고)
* HTML을 만들기 위한 코틀린 DSL로, 타입 안전한 빌더(type-safe builder)의 대표적인 예
* 객체 계층 구조를 선언적으로 정의할 수 있음
* 모든 중첩 태그를 저장하는 리스트는 각 태그를 저장해두고 재귀로 호출하여 닫는 태그를 추가하기 위해 사용함
* 부모 태그가 가진 자식 목록에 추가하므로 동적으로 태그를 만들 수 있음

#### 코틀린 빌더
추상화와 재사용을 가능하게 하는 도구로 내부 DSL을 사용하면 일반 코드와 마찬가지로 반복되는 내부 DSL 코드 조각을 새 함수로 묶어서 재사용할 수 있음

### invoke 관례를 사용한 더 유연한 블록 중첩
* invoke 관례를 사용하면 객체를 함수처럼 호출할 수 있음
* 관례를 사용하면 특별한 이름이 붙은 함수를 일반 메소드 호출 구문으로 호출하지 않고 더 간단한 다른 구문으로 호출 할 수 있음

* `operator` 변경자가 붙은 invoke 메소드 정의가 들어있는 클래스의 객체는 함수처럼 부를 수 있음
* 원하는대로 파라미터 개수나 타입을 지정할 수 있음
* 여러 파라미터 타입을 지원하기 위해 오버로딩도 가능함

#### invoke 관례와 함수형 타입
* 인라인하는 람다를 제외한 모든 람다는 함수형 인터페이스(Function1 등)를 구현하는 클래스로 컴파일 됨
* 람다를 함수처럼 호출하면 이 관례에 따라 `invoke` 메소드 호출로 변환됨
* 람다를 함수 타입 인터페이스를 구현하는 클래스로 변환하고 그 클래스의 `invoke` 메소드를 오버라이드하면 복잡한 람다가 필요한 구문을 리팩토링할 수 있음

#### 내부 DSL을 사용하면 UI와 비즈니스 로직을 다른 컴포넌트로 분리할 수 있지만 모든 컴포넌트를 여전히 코틀린 코드로 작성할 수 있다.

