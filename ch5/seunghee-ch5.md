# 5. 람다로 프로그래밍

- 람다는 코드 조각이다.
- 코틀린 표준 라이브러리는 람다를 많이 사용한다.
- Lambda with Receiver: 람다 선언을 둘러싸고 있는 환경과는 다른 환경에서 람다 본문을 실행할 수 있다.



## 람다 식과 멤버 참조
### 람다 소개: 코드 블록을 함수 인자로 넘기기

- 객체 간 데이터뿐만 아니라 "무엇을 할 지"를 전달하기 위해 람다가 필요하다.
- 람다는 Functional Interface 구현의 다른 형태이다.


### 람다와 컬렉션
- 람다를 이용해서 외부 반복을 내부 반복으로 바꿀 수 있다.


### 람다식의 문법

- ```kotlin
  val sum = {x: Int, y: Int -> x+y} // 람다는 값
  println(sum(1,2)) // 람다 뒤에 괄호로 실행할 수 있다.
  run{println(42)} // run: 람다식을 실행하는 함수
  ```

- x, y : 파라미터, x+y : 본문

- 람다식은 중괄호로 둘러쌓여 있다.

- 람다는 인라인되어 함수 호출에 필요한 비용이 들지 않는다.

- 람다식 줄여쓰기

- ```kotlin
  people.maxBy({p:Person -> p.age}) // maxBy는 funtion 타입 람다식을 인자로 받는다.
  people.maxBy(){p:Person -> p.age} // 맨 뒤 인자가 람다식이면 괄호 밖으로 꺼낼 수 있다.
  people.maxBy{p->p.age} // 빈괄호, 타입 생략
  peol.maxBy{it.age} // 파라미터가 하나뿐이고 추론 가능하다면 it를 바로 쓸 수 있다.
  ```

### 람다식에서 로컬 변수에 접근하기

- 람다를 함수 안에서 정의하면 파라미터와 로컬 변수를 사용할 수 있다.
- 람다는 별도 쓰레드에서 실행 가능하다.
- 로컬 변수는 스택에 저장되고, 쓰레드는 각자 다른 스택을 사용하기 때문에 람다와 로컬 변수는 사용하는 스택이 다를 수 있다.
- 따라서 람다가 사용하는 로컬 변수는 final 한 성격이어야한다.
- 코틀린은 람다가 사용하는 로컬 변수인 포획 변수를 final 객체로 래핑해서 사용한다.
- 래퍼 객체의 참조를 람다와 함께 저장한다.


## 컬렉션 함수형 API

자료구조 Map에 필터와 맵을 사용할 때 filterKeys 나 mapValues 등을 이용해서 특정 엔트리를 걸러내거나 변환할 수 있다.



### all, any, count, find

- all: 모든 원소가 인자로 받은 predicate를 만족하는지

- any: 인자로 받은 predicate를 하나라도 만족하는 원소가 있는지

- count: predicate를 만족하는 원소의 개수 반환
- find: predicate를 만족하는 원소 중 첫번째꺼, 없으면 null
- filter + size를 쓰면 임시 컬렉션이 필요하지만 count는 그렇지 않다.



## 지연 계산(lazy) 컬렉션 연산
- 코틀린 시퀀스 == 자바 스트림
- 시퀀스를 사용하면 중간 임시 컬렉션을 만들지 않고 컬렉션 연산을 수행할 수 있다.
- 시퀀스를 안쓸때: 연산 하나하나마다 전체 원소에 대해 전부 수행
- 시퀀스 쓰면: 원소 하나하나 모든 연산 수행
- 모든 연산을 한번에 하므로 중간 연산자는 최종 연산자까지 지연된다.



### 중간 연산자, 최종 연산자
- map, filter, .. : 중간 연산자.
- toList, ... : 최종 연산자.
- 컬렉션의 각 원소는 각 원소마다 계산이 한번에 이루어지므로 중간 연산자는 최종 연산자 전까지 미뤄진다.
- 즉시계산은 모든 원소에 대한 중간계산 결과를 저장할 버퍼가 필요하므로 메모리 사용이 더 많다.
- filter 다음 map을 쓰면 map 다음 filter 쓰는 것보다 연산량이 줄어든다.
- 
### 시퀀스 만들기
- generateSequence(): 이전의 원소를 받아서 다음 원소를 계산하는 시퀀스
- 첫째항을 첫번째 인자로, 점화식을 람다식으로 건넨다.



### 자바 메소드에 람다를 인자로 전달하기

- 람다를 인자로 전달하면 실행 시 싱글턴 객체가 만들어진다.
- 외부에서 val로 만들어서 참조를 전달하는 것과 동일하다.
- 익명 객체를 만들어서 전달하면 매번 객체가 생성된다.
- 람다가 포획변수가 있다면 매번 새로운 객체를 생성한다.
- inline이 붙어있는 함수에 람다를 넘기면 객체가 생성되지 않고 인라인된다.


### SAM 생성자 : 람다를 객체로 만들기

- SAM: Single Abstract Method
- SAM 생성자는 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수다.

- 람다를 인스턴스 변수에 저장하거나 재사용 될 때 등에 사용한다.
- 람다가 자기 자신을 가리키기 위해서 this를 사용할 수 없으므로 this를 사용할 수 있는 익명 객체를 사용하기 위해 SAM을 사용한다
- SAM을 파라미터로 받는 람다는 메서드를 호출할때 SAM으로 자동 변환되지만 잘 안되면 명시적으로 생성자로 변경 필ㄷ요


## 수신객체지정람다(Lambda with receiver) : with 와 apply